# 2026-02-19 개발 일지

## 개요

UXAgent Extension의 에이전트 관찰(Observation) 시스템을 전면 개편하고, 실제 태스크 수행 테스트(쿠팡 "가장 저렴한 도넛 구매")를 통해 발견된 문제들을 반복 수정한 하루.

**변경 규모**: 10개 파일, +1,329줄 / -107줄, 총 14개 커밋

---

## 주요 작업 내용

### 1. Auto Run 루프 구현
> `2beb952`

- Auto Run / Stop 버튼 + 최대 스텝 설정 (기본 20)
- `autoRunLoop()`: DOM 캡처 → AI 분석 → 액션 실행 → 3초 대기 → 반복
- AI가 `DONE`/`CONTINUE` 신호를 출력해 태스크 완료를 자동 감지
- 중단 조건: 태스크 완료, 최대 스텝 도달, Stop 클릭, 액션 실패

### 2. Agent Flow 4단계 UI
> `6c41e14`

- 기존 단일 출력 → **4단계 사고과정** 시각화
  1. Reasoning Input (프롬프트) — 파란 뱃지, 기본 접힘
  2. Reasoning Output — 초록 뱃지, 기본 펼침
  3. Action Input (프롬프트) — 파란 뱃지, 기본 접힘
  4. Action Output — 초록 뱃지, 기본 펼침
- 서버에서 `reasoningPrompt`, `actionPrompt`를 별도 필드로 반환

### 3. 액션 검증(Verify) 단계 추가
> `ddba872`, `b4519ed`

- memoryStream 항목이 `pending` → `success`/`failed`로 상태 변화
- `PUT /api/captures/:captureId/verify` 엔드포인트 추가
- Reasoning 프롬프트에 실행 상태 표시 (✓/✗/⏳)
- Mongoose subdocument 변경 감지를 위해 `markModified()` 추가

### 4. Observe 모듈 도입 → 3단계 에이전트 플로우
> `7fb403e`

기존 2단계(Reasoning → Action)에서 **3단계(Observe → Reasoning → Action)** 로 확장:

| 단계 | 역할 |
|------|------|
| **Observe** | 현재 페이지 상태를 객관적으로 기술, 이전 액션 검증 (VERIFIED/FAILED) |
| **Reasoning** | Observe 결과를 기반으로 전략 수립 |
| **Action** | 구체적인 실행 명령 생성 |

- UI: 6단계 Agent Flow (Observe 2단계 + Reasoning 2단계 + Action 2단계)
- Observe 단계는 주황색 뱃지로 시각 구분

### 5. AX Tree + Element ID (eid) 기반 Observation 시스템
> `538d44e` — 이 날의 핵심 작업

**문제**: 기존 `content.js`의 인덱스 기반 ID (`item0`, `item1`)는 페이지 변경 시 ID가 불안정하고, 접근성 정보(role, name, states)가 부족.

**해결**: DOM 기반 접근성 트리 추출 + 안정적 fingerprint 해시 ID

#### 새 파일

| 파일 | 역할 |
|------|------|
| `ax-extract.js` | 클라이언트 AX 추출 (동적 주입 content script) |
| `server/lib/observation.js` | 서버 사이드 observation 조립 + 프롬프트 포매팅 |

#### 핵심 설계

- **Fingerprint eid**: `role\|tag\|accessibleName\|stableAttr`의 djb2 해시 → `e-a3f2b1c0`
  - 같은 요소는 step이 바뀌어도 동일 eid 유지
- **듀얼 ID 시스템**: AI는 eid로 참조, `background.js`에서 eid → CSS selector 변환, `runner.js`는 변경 없음
- **Accessible Name 계산**: WAI-ARIA 간소화 (labelledby → aria-label → label[for] → alt → title → placeholder → textContent)
- **Observation 스키마**:
  ```
  { step, ts, page, last_action, ax: { mode, tree_summary, interactive_elements[] }, errors }
  ```

### 6. 키보드 액션 확장
> `fafaf89`

**문제**: 에이전트가 검색창에 입력 후 검색을 실행하지 못함 (Enter 키 없음).

**추가된 액션**:

| 액션 | 용도 |
|------|------|
| `type` + `pressEnter:true` | 입력 후 바로 폼 제출 |
| `press_enter` | 이미 포커스된 필드에서 Enter 전송 |
| `keypress` | 특수 키 전송 (Escape, Tab, Arrow 등) |
| `back` | 브라우저 뒤로가기 |

- `runner.js`에 `dispatchKey()` 헬퍼 + KEY_MAP 추가
- `doType()`에서 실제 키보드 이벤트 dispatch (keydown/keypress/keyup)

### 7. Step 히스토리 네비게이션
> `48a3ab0`

- 이전 step의 Agent Flow 데이터를 `< Step N / M >` UI로 탐색 가능
- `flowHistory[]` 배열에 각 step 데이터 저장
- 태스크 종료 후에도 히스토리 유지

---

## 실전 테스트에서 발견된 버그 & 수정

쿠팡 "가장 저렴한 도넛 구매" 태스크 수행 중 발견된 문제들:

### Bug 1: 숨겨진 라디오 버튼 클릭 불가
> `5863dbc`

- **증상**: "낮은가격순" 정렬 버튼을 찾지 못함
- **원인**: `<input type="radio">`가 `position:absolute; left:-9999px`로 CSS 숨김 처리, 실제 클릭 대상은 `<label>`인데 캡처되지 않음
- **수정**: `isOffScreen()` + `findVisibleProxy()` 추가
  - label[for=id] → 감싸는 label → 부모 li 순서로 프록시 탐색
  - 프록시의 좌표/selector 사용, 원본의 시맨틱 정보(role, name, states) 유지

### Bug 2: isOffScreen() 과잉 감지
> `bead52b`

- **증상**: 스크롤해야 보이는 정상 요소(양수 좌표)까지 숨김 처리
- **원인**: viewport 기준 margin 500px로 판정 → 긴 페이지의 아래쪽 요소도 off-screen 취급
- **수정**: CSS 숨김은 항상 큰 음수 좌표 사용 → `rect.right < -1000 || rect.bottom < -1000`만 체크

### Bug 3: 상품 링크가 top-50에 포함되지 않음
> `4927793`, `ded2435`

- **증상**: `Element e-0f2c754e not found on page` 오류
- **원인**: nav/header 링크가 50개 슬롯을 모두 차지 → 상품 링크 0개
- **수정 1차**: chrome(nav/header) vs content 2티어 분리, chrome 최대 10슬롯
- **수정 2차**: 3티어 분리 — chrome(8) / filter(7) / main(35)

### Bug 4: 정렬 라디오가 filter 티어에서 밀려남
> `8f3f3f3`

- **증상**: "낮은가격순" 다시 목록에서 누락
- **원인**: 모든 radio/checkbox를 무조건 filter 티어로 분류 → 카테고리 링크(5) + 가격 입력(2)으로 7슬롯 소진 → 정렬 라디오 잘림
- **수정**: radio/checkbox는 parent_context가 FILTER_PATTERN 매칭될 때만 filter 분류

---

## 아키텍처 리팩토링: Landmark 기반 분류
> `18951ba`

이전까지의 element 분류는 **사이트 특화 패턴**에 의존:

```js
// Before: 쿠팡 전용 클래스명 + 매직넘버 좌표
const CHROME_PATTERN = /gnb|header|footer|\.fw-float|\.cs-center/i;
if (el.rect.y < 200) return "chrome";
if (el.rect.x < 100 && el.rect.y > 300) return "filter";
```

**웹 표준(HTML5/ARIA Landmark) 기반**으로 전면 교체:

```js
// After: 어떤 사이트에서든 동작
function getNearestLandmark(el) {
  // DOM 워크업: <nav>→navigation, <aside>→complementary, <main>→main ...
}

function classifyElement(el) {
  if (["navigation", "banner", "contentinfo"].includes(el.landmark)) return "chrome";
  if (el.landmark === "complementary") return "filter";
  return "main";
}
```

| 비교 | Before | After |
|------|--------|-------|
| 분류 기준 | CSS 클래스 regex + 좌표 | HTML5/ARIA landmark |
| 사이트 범용성 | 쿠팡 전용 패턴 포함 | 모든 사이트 동일 |
| 좌표 의존 | y<200, x<100 등 하드코딩 | 없음 |
| Landmark 없는 사이트 | 오분류 위험 | 전부 main → 스코어링으로 우선순위 결정 |

---

## 변경 파일 요약

| 파일 | 변경 내용 |
|------|-----------|
| `ax-extract.js` | **신규** — AX 추출, eid fingerprint, 프록시 감지, landmark 탐지 |
| `server/lib/observation.js` | **신규** — observation 조립, 3티어 pruning, 프롬프트 포매팅 |
| `sidepanel.js` | Auto Run, AX 주입, flow 히스토리, 6단계 UI 업데이트 |
| `sidepanel.html` | 6단계 Agent Flow UI, 히스토리 네비게이션, Auto Run 컨트롤 |
| `server/routes/api.js` | Observe/Reasoning/Action 3단계 프롬프트, eid 기반 명령 파싱 |
| `background.js` | eid→selector 해석, 키보드 액션, back 액션 |
| `runner.js` | dispatchKey(), pressEnter, keypress 액션 |
| `server/models/Capture.js` | observation, axMode 필드 추가 |
| `server/models/Task.js` | memoryStream 상태 관리 |
| `manifest.json` | 버전 0.3.0 → 0.4.0 |

---

## 오늘의 교훈

1. **실전 테스트가 설계를 검증한다**: AX 추출 시스템을 설계대로 구현한 뒤, 실제 쿠팡 태스크에서 4개의 버그가 연쇄적으로 발견됨. 각 버그는 이전 수정이 만든 새로운 엣지케이스.

2. **사이트 특화 패턴은 기술 부채**: CSS 클래스명, 좌표 하드코딩은 한 사이트에서만 동작. 웹 표준(HTML5 landmark)을 활용하면 별도 패턴 없이 모든 사이트에서 동작.

3. **pruning은 보이지 않는 병목**: AI가 올바른 요소를 선택 못 하는 문제의 근본 원인이 "AI가 그 요소를 아예 볼 수 없었음"인 경우가 많음. 어떤 요소가 top-K에 포함되는지가 에이전트 성능의 핵심.
